# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/app.ipynb (unless otherwise specified).

__all__ = ['create_loader', 'df', 'get_price_and_distance', 'pong', 'predict', 'app', 'DEVICE', 'MODEL',
           'UPLOAD_FOLDER', 'file_id', 'destination', 'nn_preds', 'files']

# Cell
import io
import sys
import os
import bcolz
import torch
import PIL
import uvicorn

import numpy as np
import pandas as pd

import snapworth.config as config
import snapworth.models.models as models
import snapworth.dataset.dataset as dataset
import snapworth.utils.utils as utils
import snapworth.utils.indexer as indexer
import matplotlib.pyplot as plt

# import flask
# from flask import Flask
# from flask import request
# from flask import render_template

from fastapi import FastAPI, File, UploadFile, HTTPException
from starlette.requests import Request
from pathlib import Path
from pyngrok import ngrok
from tqdm import tqdm
from collections import defaultdict

# Cell
def create_loader(imgs, lbls, bs, resize=True, drop_last=False, shuffle=False, config=config):
    assert len(imgs) == len(lbls)
    image_ds = dataset.ImageDataset(imgs, lbls, resize=resize, config=config) #excluded from utils becuase of config
    image_dl = torch.utils.data.DataLoader(image_ds, batch_size=bs, drop_last=drop_last,
                                        num_workers=5, shuffle=shuffle)
    return image_dl

# Cell
df = pd.read_csv(config.DATA_PATH/'all_data.csv')
df['id'] = df.index.values

# Cell
app = FastAPI()

DEVICE = config.DEVICE
MODEL = models.SnapModel().to(DEVICE)
UPLOAD_FOLDER = os.path.join(config.DATA_PATH)  #the temp files will be saved here. Think about changing to STATIC_PATH

file_id = "1Z2a0Gp-f6kOFVGSbfEUA7Fb3IfglaWja" #Id for gdrive file... image_vecs/index
destination = config.IMAGE_VECS_PATH/'index'
if not os.path.exists(str(destination)):
    utils.download_file_from_google_drive(file_id, destination)

nn_preds = indexer.create_index(np.array([[0]]))
nn_preds.loadIndex(filename=os.path.join(config.IMAGE_VECS_PATH/'index'))#, load_data=True)

files = np.load(config.DATA_PATH/'all_image_paths.npy', allow_pickle=True)

# with open(os.path.join(os.getcwd(), 'templates', 'index.html'), 'w') as file_:
#     text = "<!doctype html> \n\
# <title>Upload new File</title> \n\
# <h1>Upload new File</h1> \n\
# <form method=post enctype=multipart/form-data> \n\
#     <input type=file name=image> \n\
#     <input type=submit value=Upload> \n\
#     <h1>{{prediction}}</h1> \n\
# </form>"
#     file_.write(text)


def get_price_and_distance(image, model, database, all_images_list, device):
    test_ds = dataset.ImageDataset([image], lbls=[0], resize=True, config=config)

    with torch.no_grad():
        activs = model.eval()(test_ds[0]['image'].unsqueeze(0).to(device))

    idxs,dists = indexer.get_knn(nn_preds, activs.detach().to('cpu'))

    product_prices = []
    product_image_urls = []
    product_urls = []
    product_names = []
    product_categories = []

    similar_images = []
    distances = []

    for i, dist in zip(idxs[:6], dists[:6]):
        im_id = Path(all_images_list[i]).name[:-4]
        df_ = database.query(f'id == {im_id}')
        product_price = df_.product_price.values[0]
        product_image_url = df_.product_image_url.values[0]
        product_url = df_.product_url.values[0]
        product_name = df_.product_name.values[0]
        product_category = df_.product_category.values[0]

        sim = round(float(dist), 5)

        product_prices.append(product_price)
        product_image_urls.append(product_image_url)
        product_urls.append(product_url)
        product_names.append(product_name)
        product_categories.append(product_category)

        similar_images.append(all_images_list[i])
        distances.append(sim)

    return [product_prices, product_image_urls, product_urls, product_names, product_categories], distances, similar_images

@app.get("/ping")
async def pong():
    return {"ping": "pong!"}

@app.post('/predict', status_code=200)
async def predict(file: bytes = File(...)):

    # ensure an image was properly uploaded to the endpoint
    image_file = PIL.Image.open(io.BytesIO(file))
    image_location = os.path.join(UPLOAD_FOLDER, 'temp.jpg')
    image_file.save(image_location)

#     try:
#         product_list, distances, similar_images = get_price_and_distance(image_location, MODEL, df, files, DEVICE)
#     except:
#         raise HTTPException(status_code=400, detail="Something went Wrong")
    product_list, distances, similar_images = get_price_and_distance(image_location, MODEL, df, files, DEVICE)

    os.remove(image_location)

    data = []
    for pp, piu, pu, pn, pc in zip(product_list[0], product_list[1], product_list[2], product_list[3], product_list[4]):
        data.append(
                {'product_prices': pp,
                'product_image_urls': piu,
                'product_urls': pu,
                'product_names': pn,
                'product_categories': pc,
                })

    return data

# #for test with ngrok
# if __name__ == '__main__':
#     public_url = ngrok.connect(port=1234)
#     print(public_url)
# #     uvicorn.run("app:app", host="0.0.0.0", port=os.environ.get('PORT', 5000), workers=4)#, reload=True)
#     uvicorn.run("app:app", host="127.0.0.1", port=1234, workers=4, reload=True)